<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spooky 4x4 Tic-Tac-Toe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #000000 0%, #0a0a0a 100%);
            color: #b388ff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            max-width: 600px;
            width: 100%;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px #7c4dff, 0 0 40px #7c4dff;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 20px #7c4dff, 0 0 40px #7c4dff;
            }
            to {
                text-shadow: 0 0 30px #9575cd, 0 0 60px #9575cd;
            }
        }

        .status {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            min-height: 2rem;
            color: #ce93d8;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 0 auto 2rem;
            max-width: 500px;
            padding: 20px;
            background: rgba(26, 13, 46, 0.3);
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(124, 77, 255, 0.3);
        }

        .cell {
            aspect-ratio: 1;
            background: #1a0d2e;
            border: 2px solid #7c4dff;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .cell:hover:not(.occupied):not(.game-over) {
            background: #2a1d3e;
            border-color: #9575cd;
            box-shadow: 0 0 20px rgba(149, 117, 205, 0.5);
        }

        .cell:focus {
            outline: 3px solid #b388ff;
            outline-offset: 2px;
            border-color: #ce93d8;
        }

        .cell:focus:not(.occupied):not(.game-over) {
            background: #2a1d3e;
            box-shadow: 0 0 25px rgba(179, 136, 255, 0.6);
        }

        .cell.occupied {
            cursor: not-allowed;
        }

        .cell.game-over {
            cursor: not-allowed;
        }

        .cell .mark {
            animation: fadeIn 0.4s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.5);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .cell .preview {
            opacity: 0.3;
            transition: opacity 0.2s ease;
        }

        .cell.winning {
            background: #2a0d4e;
            border-color: #ce93d8;
            animation: winGlow 1s ease-in-out infinite alternate;
        }

        @keyframes winGlow {
            from {
                box-shadow: 0 0 30px #ce93d8, 0 0 50px #ce93d8, 0 0 70px #7c4dff;
            }
            to {
                box-shadow: 0 0 40px #b388ff, 0 0 70px #b388ff, 0 0 100px #9575cd;
            }
        }

        .mark-x {
            color: #ff6ec7;
            text-shadow: 0 0 10px #ff6ec7;
        }

        .mark-o {
            color: #69f0ae;
            text-shadow: 0 0 10px #69f0ae;
        }

        .restart-button {
            display: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            background: #7c4dff;
            color: #ffffff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(124, 77, 255, 0.5);
        }

        .restart-button:hover {
            background: #9575cd;
            box-shadow: 0 0 30px rgba(149, 117, 205, 0.7);
            transform: translateY(-2px);
        }

        .restart-button:active {
            transform: translateY(0);
        }

        .restart-button.visible {
            display: inline-block;
            animation: fadeIn 0.5s ease-in;
        }

        .score-display {
            display: flex;
            justify-content: center;
            gap: 3rem;
            margin-bottom: 1.5rem;
            font-size: 1.2rem;
        }

        .score-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 20px;
            background: rgba(26, 13, 46, 0.5);
            border: 2px solid #7c4dff;
            border-radius: 10px;
        }

        .score-label {
            color: #9575cd;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .score-value {
            color: #b388ff;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .player-names {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1.5rem;
        }

        .name-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .name-input-group label {
            color: #9575cd;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .name-input-group input {
            background: #1a0d2e;
            border: 2px solid #7c4dff;
            border-radius: 5px;
            color: #b388ff;
            padding: 8px 12px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            text-align: center;
            width: 150px;
            transition: all 0.3s ease;
        }

        .name-input-group input:focus {
            outline: none;
            border-color: #9575cd;
            box-shadow: 0 0 10px rgba(149, 117, 205, 0.5);
        }

        .name-input-group input::placeholder {
            color: #6a4d8a;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Responsive design */
        @media (max-width: 600px) {
            h1 {
                font-size: 2rem;
            }

            .status {
                font-size: 1.2rem;
            }

            .game-board {
                gap: 8px;
                padding: 15px;
            }

            .cell {
                font-size: 2rem;
            }

            .restart-button {
                padding: 12px 30px;
                font-size: 1rem;
            }
        }

        @media (max-width: 400px) {
            h1 {
                font-size: 1.5rem;
            }

            .status {
                font-size: 1rem;
            }

            .game-board {
                gap: 6px;
                padding: 10px;
            }

            .cell {
                font-size: 1.5rem;
                border-width: 1px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üëª Spooky Tic-Tac-Toe üëª</h1>
        <div class="player-names">
            <div class="name-input-group">
                <label for="nameX">üëª Player X Name</label>
                <input type="text" id="nameX" placeholder="Player X" maxlength="20" aria-label="Enter name for Player X">
            </div>
            <div class="name-input-group">
                <label for="nameO">üíÄ Player O Name</label>
                <input type="text" id="nameO" placeholder="Player O" maxlength="20" aria-label="Enter name for Player O">
            </div>
        </div>
        <div class="score-display">
            <div class="score-item">
                <div class="score-label" id="labelX">üëª Player X</div>
                <div class="score-value" id="scoreX">0</div>
            </div>
            <div class="score-item">
                <div class="score-label" id="labelO">üíÄ Player O</div>
                <div class="score-value" id="scoreO">0</div>
            </div>
        </div>
        <div class="status" id="status">Player X's Turn</div>
        <div class="game-board" id="gameBoard" role="grid" aria-label="4 by 4 Tic Tac Toe game board"></div>
        <button class="restart-button" id="restartButton" aria-label="Start a new game">Play Again</button>
        <div aria-live="polite" aria-atomic="true" class="sr-only" id="announcements"></div>
    </div>

    <script>
        // ===== Spooky Victory Messages =====
        const SPOOKY_MESSAGES = [
            "{winner} has summoned victory from the shadows! üëª",
            "The spirits favor {winner}! üíÄ",
            "{winner} emerges from the darkness victorious! üåô",
            "A haunting win for {winner}! üï∑Ô∏è",
            "{winner}'s dark powers prevail! ‚ö°",
            "{winner} has conquered the cursed board! ü¶á",
            "Victory rises from the grave for {winner}! ‚ö∞Ô∏è",
            "{winner} channels the ancient spirits to win! üîÆ",
            "The phantom forces crown {winner} victorious! üëë",
            "{winner} has mastered the spectral game! üåü"
        ];
        
        /**
         * Gets a random spooky victory message with the winner's name
         * @param {string} winnerName - The name of the winning player
         * @returns {string} - Formatted victory message
         */
        function getSpookyVictoryMessage(winnerName) {
            const randomIndex = Math.floor(Math.random() * SPOOKY_MESSAGES.length);
            return SPOOKY_MESSAGES[randomIndex].replace('{winner}', winnerName);
        }
        
        // ===== GameState Module =====
        const GameState = {
            // 4x4 board representation (null = empty, 'X' or 'O' = player mark)
            board: [
                [null, null, null, null],
                [null, null, null, null],
                [null, null, null, null],
                [null, null, null, null]
            ],
            
            // Current player ('X' or 'O')
            currentPlayer: 'X',
            
            // Game over flag
            gameOver: false,
            
            // Winner ('X', 'O', 'draw', or null)
            winner: null,
            
            // Scores for each player
            scores: {
                X: 0,
                O: 0
            },
            
            // Player names
            playerNames: {
                X: 'Player X',
                O: 'Player O'
            },
            
            /**
             * Increments the score for the specified player
             * @param {string} player - 'X' or 'O'
             */
            incrementScore(player) {
                if (player === 'X' || player === 'O') {
                    this.scores[player]++;
                }
            },
            
            /**
             * Sets a custom name for a player
             * @param {string} player - 'X' or 'O'
             * @param {string} name - Custom name
             */
            setPlayerName(player, name) {
                if (player === 'X' || player === 'O') {
                    // Use default if name is empty or whitespace
                    const trimmedName = name.trim();
                    this.playerNames[player] = trimmedName || `Player ${player}`;
                }
            },
            
            /**
             * Validates if a move can be made at the specified position
             * @param {number} row - Row index (0-3)
             * @param {number} col - Column index (0-3)
             * @returns {boolean} - True if move is valid, false otherwise
             */
            isValidMove(row, col) {
                // Check bounds
                if (row < 0 || row > 3 || col < 0 || col > 3) {
                    return false;
                }
                
                // Check if game is over
                if (this.gameOver) {
                    return false;
                }
                
                // Check if cell is empty
                return this.board[row][col] === null;
            },
            
            /**
             * Makes a move at the specified position
             * @param {number} row - Row index (0-3)
             * @param {number} col - Column index (0-3)
             * @returns {boolean} - True if move was successful, false otherwise
             */
            makeMove(row, col) {
                // Validate move
                if (!this.isValidMove(row, col)) {
                    return false;
                }
                
                // Place mark
                this.board[row][col] = this.currentPlayer;
                
                // Switch player
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                
                return true;
            },
            
            /**
             * Resets the board for a new round (preserves scores)
             */
            reset() {
                // Clear board
                this.board = [
                    [null, null, null, null],
                    [null, null, null, null],
                    [null, null, null, null],
                    [null, null, null, null]
                ];
                
                // Reset to player X
                this.currentPlayer = 'X';
                
                // Reset game over state
                this.gameOver = false;
                
                // Reset winner
                this.winner = null;
                
                // Note: scores are preserved across rounds
            },
            
            /**
             * Resets everything including scores
             */
            resetAll() {
                this.reset();
                this.scores = { X: 0, O: 0 };
            }
        };
        
        // ===== UI Controller =====
        const UIController = {
            gameBoard: document.getElementById('gameBoard'),
            statusElement: document.getElementById('status'),
            restartButton: document.getElementById('restartButton'),
            
            /**
             * Returns the emoji for a given player
             * @param {string} player - 'X' or 'O'
             * @returns {string} - Emoji representation
             */
            getEmojiForPlayer(player) {
                return player === 'X' ? 'üëª' : 'üíÄ';
            },
            
            /**
             * Renders the 4x4 game board
             */
            renderBoard() {
                this.gameBoard.innerHTML = '';
                
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.setAttribute('tabindex', '0');
                        cell.setAttribute('role', 'button');
                        
                        const value = GameState.board[row][col];
                        if (value) {
                            const mark = document.createElement('span');
                            mark.className = `mark mark-${value.toLowerCase()}`;
                            mark.textContent = this.getEmojiForPlayer(value);
                            cell.appendChild(mark);
                            cell.classList.add('occupied');
                        }
                        
                        if (GameState.gameOver) {
                            cell.classList.add('game-over');
                        }
                        
                        // Add ARIA label
                        AccessibilityController.updateCellLabel(cell, row, col, value);
                        
                        // Add keyboard event listener
                        cell.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                cell.click();
                            }
                        });
                        
                        this.gameBoard.appendChild(cell);
                    }
                }
            },
            
            /**
             * Updates the status message
             */
            updateStatus() {
                let message = '';
                
                if (GameState.gameOver) {
                    if (GameState.winner === 'draw') {
                        message = "It's a Draw! üëª";
                    } else {
                        const winnerName = GameState.playerNames[GameState.winner];
                        message = getSpookyVictoryMessage(winnerName);
                    }
                    this.restartButton.classList.add('visible');
                    AccessibilityController.announce(message);
                } else {
                    const currentName = GameState.playerNames[GameState.currentPlayer];
                    message = `${currentName}'s Turn`;
                    AccessibilityController.announce(message);
                }
                
                this.statusElement.textContent = message;
            },
            
            /**
             * Updates the score display
             */
            updateScoreDisplay() {
                document.getElementById('scoreX').textContent = GameState.scores.X;
                document.getElementById('scoreO').textContent = GameState.scores.O;
                document.getElementById('labelX').textContent = `üëª ${GameState.playerNames.X}`;
                document.getElementById('labelO').textContent = `üíÄ ${GameState.playerNames.O}`;
            },
            
            /**
             * Highlights winning cells
             */
            highlightWinningCells(cells) {
                cells.forEach(({row, col}) => {
                    const cell = this.gameBoard.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (cell) {
                        cell.classList.add('winning');
                    }
                });
            }
        };
        
        // ===== Accessibility Controller =====
        const AccessibilityController = {
            announcementElement: null,
            
            /**
             * Initializes the accessibility controller
             */
            init() {
                this.announcementElement = document.getElementById('announcements');
            },
            
            /**
             * Announces a message to screen readers
             * @param {string} message - Message to announce
             */
            announce(message) {
                if (!this.announcementElement) {
                    this.init();
                }
                
                if (this.announcementElement) {
                    this.announcementElement.textContent = message;
                }
            },
            
            /**
             * Updates ARIA labels for a cell
             * @param {HTMLElement} cell - The cell element
             * @param {number} row - Row index
             * @param {number} col - Column index
             * @param {string} value - Cell value ('X', 'O', or null)
             */
            updateCellLabel(cell, row, col, value) {
                const position = `Row ${row + 1}, Column ${col + 1}`;
                let label = position;
                
                if (value) {
                    const playerName = GameState.playerNames[value];
                    const emoji = value === 'X' ? 'ghost' : 'skull';
                    label = `${position}, ${playerName} ${emoji}`;
                } else {
                    label = `${position}, empty`;
                }
                
                cell.setAttribute('aria-label', label);
            }
        };
        
        // ===== Audio Controller =====
        const AudioController = {
            audioContext: null,
            
            /**
             * Initializes the audio context
             */
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            },
            
            /**
             * Plays a creepy sound effect
             */
            playWinSound() {
                if (!this.audioContext) {
                    this.init();
                }
                
                if (!this.audioContext) return;
                
                try {
                    const now = this.audioContext.currentTime;
                    
                    // Create oscillators for a creepy chord
                    const osc1 = this.audioContext.createOscillator();
                    const osc2 = this.audioContext.createOscillator();
                    const osc3 = this.audioContext.createOscillator();
                    
                    // Create gain nodes for volume control
                    const gain1 = this.audioContext.createGain();
                    const gain2 = this.audioContext.createGain();
                    const gain3 = this.audioContext.createGain();
                    const masterGain = this.audioContext.createGain();
                    
                    // Set frequencies for a spooky minor chord
                    osc1.frequency.value = 220; // A3
                    osc2.frequency.value = 261.63; // C4
                    osc3.frequency.value = 329.63; // E4
                    
                    // Use different waveforms for texture
                    osc1.type = 'sine';
                    osc2.type = 'triangle';
                    osc3.type = 'sawtooth';
                    
                    // Connect oscillators to gains
                    osc1.connect(gain1);
                    osc2.connect(gain2);
                    osc3.connect(gain3);
                    
                    // Connect gains to master gain
                    gain1.connect(masterGain);
                    gain2.connect(masterGain);
                    gain3.connect(masterGain);
                    
                    // Connect master gain to output
                    masterGain.connect(this.audioContext.destination);
                    
                    // Set initial volumes
                    gain1.gain.value = 0.3;
                    gain2.gain.value = 0.2;
                    gain3.gain.value = 0.1;
                    masterGain.gain.value = 0.3;
                    
                    // Fade out envelope
                    masterGain.gain.setValueAtTime(0.3, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                    
                    // Start oscillators
                    osc1.start(now);
                    osc2.start(now);
                    osc3.start(now);
                    
                    // Stop oscillators after sound completes
                    osc1.stop(now + 1.5);
                    osc2.stop(now + 1.5);
                    osc3.stop(now + 1.5);
                    
                } catch (e) {
                    console.log('Error playing sound:', e);
                }
            }
        };
        
        // ===== Win Detector =====
        const WinDetector = {
            /**
             * Checks if four cells contain the same non-null value
             */
            checkLine(cells) {
                const values = cells.map(({row, col}) => GameState.board[row][col]);
                const first = values[0];
                
                if (first === null) return null;
                
                if (values.every(v => v === first)) {
                    return { winner: first, cells };
                }
                
                return null;
            },
            
            /**
             * Checks all rows for wins
             */
            checkRows() {
                for (let row = 0; row < 4; row++) {
                    const cells = [
                        {row, col: 0},
                        {row, col: 1},
                        {row, col: 2},
                        {row, col: 3}
                    ];
                    const result = this.checkLine(cells);
                    if (result) return result;
                }
                return null;
            },
            
            /**
             * Checks all columns for wins
             */
            checkColumns() {
                for (let col = 0; col < 4; col++) {
                    const cells = [
                        {row: 0, col},
                        {row: 1, col},
                        {row: 2, col},
                        {row: 3, col}
                    ];
                    const result = this.checkLine(cells);
                    if (result) return result;
                }
                return null;
            },
            
            /**
             * Checks both diagonals for wins
             */
            checkDiagonals() {
                // Main diagonal
                const mainDiag = [
                    {row: 0, col: 0},
                    {row: 1, col: 1},
                    {row: 2, col: 2},
                    {row: 3, col: 3}
                ];
                let result = this.checkLine(mainDiag);
                if (result) return result;
                
                // Anti-diagonal
                const antiDiag = [
                    {row: 0, col: 3},
                    {row: 1, col: 2},
                    {row: 2, col: 1},
                    {row: 3, col: 0}
                ];
                result = this.checkLine(antiDiag);
                if (result) return result;
                
                return null;
            },
            
            /**
             * Checks all win conditions
             */
            checkWin() {
                let result = this.checkRows();
                if (result) return result;
                
                result = this.checkColumns();
                if (result) return result;
                
                result = this.checkDiagonals();
                if (result) return result;
                
                return null;
            },
            
            /**
             * Checks for draw condition
             */
            checkDraw() {
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (GameState.board[row][col] === null) {
                            return false;
                        }
                    }
                }
                return true;
            }
        };
        
        // ===== Event Handlers =====
        function handleCellClick(event) {
            const cell = event.target.closest('.cell');
            if (!cell) return;
            
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            // Store current player before move
            const player = GameState.currentPlayer;
            
            // Attempt move
            if (GameState.makeMove(row, col)) {
                // Update UI
                UIController.renderBoard();
                applyHoverEffects();
                
                // Check for win
                const winResult = WinDetector.checkWin();
                if (winResult) {
                    GameState.gameOver = true;
                    GameState.winner = winResult.winner;
                    GameState.incrementScore(winResult.winner);
                    UIController.highlightWinningCells(winResult.cells);
                    UIController.updateScoreDisplay();
                    UIController.updateStatus();
                    AudioController.playWinSound();
                    return;
                }
                
                // Check for draw
                if (WinDetector.checkDraw()) {
                    GameState.gameOver = true;
                    GameState.winner = 'draw';
                    UIController.renderBoard();
                    UIController.updateStatus();
                    return;
                }
                
                // Update status for next turn
                UIController.updateStatus();
            }
        }
        
        function handleCellHover(event) {
            const cell = event.target.closest('.cell');
            if (!cell) return;
            
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            // Only show preview for valid moves
            if (!GameState.isValidMove(row, col)) return;
            
            // Add preview mark with emoji
            const preview = document.createElement('span');
            preview.className = `preview mark-${GameState.currentPlayer.toLowerCase()}`;
            preview.textContent = UIController.getEmojiForPlayer(GameState.currentPlayer);
            cell.appendChild(preview);
        }
        
        function handleCellLeave(event) {
            const cell = event.target.closest('.cell');
            if (!cell) return;
            
            // Remove preview mark
            const preview = cell.querySelector('.preview');
            if (preview) {
                preview.remove();
            }
        }
        
        function applyHoverEffects() {
            const cells = UIController.gameBoard.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.addEventListener('mouseenter', handleCellHover);
                cell.addEventListener('mouseleave', handleCellLeave);
            });
        }
        
        function handleRestart() {
            GameState.reset();
            UIController.restartButton.classList.remove('visible');
            UIController.renderBoard();
            UIController.updateStatus();
            applyHoverEffects();
        }
        
        // ===== Initialize Game =====
        function handlePlayerNameChange(player, name) {
            GameState.setPlayerName(player, name);
            UIController.updateScoreDisplay();
            UIController.updateStatus();
        }
        
        function initGame() {
            UIController.renderBoard();
            UIController.updateStatus();
            UIController.updateScoreDisplay();
            
            // Add event listeners
            UIController.gameBoard.addEventListener('click', handleCellClick);
            UIController.restartButton.addEventListener('click', handleRestart);
            
            // Add name input listeners
            document.getElementById('nameX').addEventListener('input', (e) => {
                handlePlayerNameChange('X', e.target.value);
            });
            document.getElementById('nameO').addEventListener('input', (e) => {
                handlePlayerNameChange('O', e.target.value);
            });
            
            // Apply hover effects
            applyHoverEffects();
        }
        
        // Start game when DOM is ready
        document.addEventListener('DOMContentLoaded', initGame);
        
        console.log('Spooky Tic-Tac-Toe initialized');
    </script>
</body>
</html>
